"""
Deep Exploitation Tools.

Purpose: Define tools available to the orchestrator agent
Role: Execute attacks and evaluate success
Dependencies: attack_phases (PayloadArticulation, Conversion, AttackExecution)

The orchestrator has access to:
    - execute_attack: Run Phase 1-2-3 pipeline with given chain and framing
    - Subagents via task() tool (provided by deepagents)
"""
import logging
from typing import Any

from langchain_core.tools import tool

from services.snipers.attack_phases import (
    PayloadArticulation,
    Conversion,
    AttackExecution,
)
from services.snipers.deep_exploitation.decision_logger import get_decision_logger

logger = logging.getLogger(__name__)


@tool
async def execute_attack(
    campaign_id: str,
    target_url: str,
    selected_chain: list[str],
    preset_framing: str | None = None,
    custom_framing: dict[str, str] | None = None,
    recon_custom_framing: dict[str, str] | None = None,
    payload_count: int = 3,
    success_scorers: list[str] | None = None,
) -> dict[str, Any]:
    """
    Execute Phase 1-2-3 attack pipeline.

    Args:
        campaign_id: Campaign ID for intelligence loading
        target_url: Target endpoint URL
        selected_chain: List of converter names to apply (e.g., ["rot13", "homoglyph"])
        preset_framing: Preset framing type (e.g., "qa_testing") - used if custom_framing is None
        custom_framing: Custom framing dict with {name, system_context, user_prefix, user_suffix}
        recon_custom_framing: Recon-based framing dict with {role, context, justification}
        payload_count: Number of payloads to generate (default: 3)
        success_scorers: Scorers that MUST succeed (e.g., ["jailbreak"]).
                         If None, any scorer at MEDIUM+ counts as success.
                         Valid: jailbreak, prompt_leak, data_leak, tool_abuse, pii_exposure

    Returns:
        Dict with:
        - success: bool - Whether attack succeeded
        - score: float - Overall score (0.0-1.0)
        - responses: list[str] - Target responses
        - failure_cause: str | None - Why attack failed (if applicable)
        - error: str | None - Error message if execution failed
    """
    logger.info(f"[ExecuteAttack] Campaign: {campaign_id}")
    logger.info(f"  Target: {target_url}")
    logger.info(f"  Chain: {selected_chain}")
    logger.info(f"  Framing: {'recon_custom' if recon_custom_framing else ('custom' if custom_framing else preset_framing)}")
    logger.info(f"  Required scorers: {success_scorers or 'any'}")

    # Log decision if decision logger is available
    decision_logger = get_decision_logger()
    if decision_logger:
        framing_choice = "recon_custom" if recon_custom_framing else ("custom" if custom_framing else preset_framing)
        decision_logger.log_decision(
            decision_type="attack_execution",
            options_considered=["preset_framing", "custom_framing", "recon_custom_framing"],
            chosen_option=str(framing_choice),
            reasoning=f"Chain: {selected_chain}, Framing: {framing_choice}",
        )

    try:
        # === Phase 1: Payload Articulation ===
        logger.info("  Phase 1: Generating payloads...")
        phase1 = PayloadArticulation()

        framing_types = [preset_framing] if preset_framing and not custom_framing else None

        phase1_result = await phase1.execute(
            campaign_id=campaign_id,
            payload_count=payload_count,
            framing_types=framing_types,
            custom_framing=custom_framing,
            recon_custom_framing=recon_custom_framing,
        )

        if not phase1_result or not phase1_result.articulated_payloads:
            return {
                "success": False,
                "score": 0.0,
                "responses": [],
                "failure_cause": "error",
                "error": "Phase 1 failed: No payloads generated",
            }

        logger.info(f"    Generated {len(phase1_result.articulated_payloads)} payloads")

        # === Phase 2: Conversion ===
        logger.info(f"  Phase 2: Converting with {selected_chain}...")
        phase2 = Conversion()

        phase2_result = await phase2.execute(
            payloads=phase1_result.articulated_payloads,
            converter_names=selected_chain if selected_chain else None,
        )

        if not phase2_result or not phase2_result.payloads:
            return {
                "success": False,
                "score": 0.0,
                "responses": [],
                "failure_cause": "error",
                "error": "Phase 2 failed: No converted payloads",
            }

        logger.info(f"    Converted {len(phase2_result.payloads)} payloads")

        # === Phase 3: Attack Execution ===
        logger.info(f"  Phase 3: Executing attack against {target_url}...")
        phase3 = AttackExecution(target_url=target_url, success_scorers=success_scorers)

        phase3_result = await phase3.execute(
            campaign_id=campaign_id,
            payloads=phase2_result.payloads,
        )

        # Extract target responses from attack_responses
        responses = []
        if phase3_result and phase3_result.attack_responses:
            for attack_response in phase3_result.attack_responses:
                # AttackResponse has 'response' attribute (str)
                if hasattr(attack_response, "response"):
                    responses.append(attack_response.response or "")
                elif isinstance(attack_response, dict):
                    responses.append(attack_response.get("response", ""))

        # Extract score (total_score, not overall_score)
        score = 0.0
        success = False
        if phase3_result:
            if hasattr(phase3_result, "total_score"):
                score = phase3_result.total_score or 0.0
            if hasattr(phase3_result, "is_successful"):
                success = phase3_result.is_successful or False

        logger.info(f"    Responses: {len(responses)}")
        logger.info(f"    Score: {score:.2f}")
        logger.info(f"    Success: {success}")

        # Determine failure cause
        failure_cause = None
        if not success:
            if score > 0.3:
                failure_cause = "partial_success"
            elif score > 0:
                failure_cause = "no_impact"
            else:
                failure_cause = "blocked"

        # Log iteration result if decision logger is available
        if decision_logger:
            framing_used = "recon_custom" if recon_custom_framing else ("custom" if custom_framing else preset_framing)
            decision_logger.log_iteration(
                iteration=0,  # Will be tracked externally by orchestrator
                chain=selected_chain,
                framing=str(framing_used),
                score=score,
                success=success,
                failure_cause=failure_cause,
            )

        return {
            "success": success,
            "score": score,
            "responses": responses,
            "failure_cause": failure_cause,
            "error": None,
        }

    except Exception as e:
        logger.error(f"  Attack execution failed: {e}")
        return {
            "success": False,
            "score": 0.0,
            "responses": [],
            "failure_cause": "error",
            "error": f"Execution error: {str(e)[:200]}",
        }


def get_orchestrator_tools() -> list:
    """Get all tools available to the orchestrator."""
    return [execute_attack]
