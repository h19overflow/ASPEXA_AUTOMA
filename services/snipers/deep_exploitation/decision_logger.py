"""
Decision Logger for Deep Exploitation.

Purpose: Capture and persist agent conversations, tool calls, and decisions
Role: Observability layer for debugging and analysis
Dependencies: logging, json, datetime
"""

import json
import logging
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from typing import Any

logger = logging.getLogger(__name__)


@dataclass
class ToolCall:
    """Record of a tool invocation."""

    name: str
    arguments: dict[str, Any]
    result: dict[str, Any] | None = None
    error: str | None = None
    timestamp: str = field(default_factory=lambda: datetime.utcnow().isoformat())


@dataclass
class SubagentDelegation:
    """Record of a subagent task delegation."""

    subagent_name: str
    task_description: str
    result: str | None = None
    timestamp: str = field(default_factory=lambda: datetime.utcnow().isoformat())


@dataclass
class Decision:
    """Record of an agent decision point."""

    decision_type: str  # e.g., "chain_selection", "framing_selection", "continue_attack"
    options_considered: list[str]
    chosen_option: str
    reasoning: str
    timestamp: str = field(default_factory=lambda: datetime.utcnow().isoformat())


@dataclass
class ConversationTurn:
    """Single turn in agent conversation."""

    role: str  # "user", "assistant", "tool"
    content: str
    tool_calls: list[ToolCall] = field(default_factory=list)
    timestamp: str = field(default_factory=lambda: datetime.utcnow().isoformat())


@dataclass
class ExecutionTrace:
    """Complete trace of a deep exploitation execution."""

    campaign_id: str
    target_url: str
    start_time: str
    end_time: str | None = None
    conversations: list[ConversationTurn] = field(default_factory=list)
    decisions: list[Decision] = field(default_factory=list)
    tool_calls: list[ToolCall] = field(default_factory=list)
    subagent_delegations: list[SubagentDelegation] = field(default_factory=list)
    iterations: list[dict[str, Any]] = field(default_factory=list)
    final_result: dict[str, Any] | None = None


class DecisionLogger:
    """
    Captures agent decisions, conversations, and tool calls.

    Provides structured logging for debugging and analysis of
    deep exploitation execution flow.
    """

    def __init__(
        self,
        campaign_id: str,
        target_url: str,
        log_dir: Path | str | None = None,
    ):
        """
        Initialize decision logger.

        Args:
            campaign_id: Campaign identifier
            target_url: Target endpoint URL
            log_dir: Directory for log files (default: ./logs/deep_exploitation)
        """
        self.trace = ExecutionTrace(
            campaign_id=campaign_id,
            target_url=target_url,
            start_time=datetime.utcnow().isoformat(),
        )
        self.log_dir = Path(log_dir) if log_dir else Path("logs/deep_exploitation")
        self.log_dir.mkdir(parents=True, exist_ok=True)
        self._current_iteration = 0

    def log_conversation_turn(
        self,
        role: str,
        content: str,
        tool_calls: list[ToolCall] | None = None,
    ) -> None:
        """Log a conversation turn."""
        turn = ConversationTurn(
            role=role,
            content=content[:2000],  # Truncate long content
            tool_calls=tool_calls or [],
        )
        self.trace.conversations.append(turn)
        logger.debug(f"[{role.upper()}] {content[:200]}...")

    def log_decision(
        self,
        decision_type: str,
        options_considered: list[str],
        chosen_option: str,
        reasoning: str,
    ) -> None:
        """Log an agent decision point."""
        decision = Decision(
            decision_type=decision_type,
            options_considered=options_considered,
            chosen_option=chosen_option,
            reasoning=reasoning,
        )
        self.trace.decisions.append(decision)
        logger.info(
            f"[DECISION] {decision_type}: {chosen_option} "
            f"(from {len(options_considered)} options)"
        )
        logger.debug(f"  Reasoning: {reasoning[:200]}...")

    def log_tool_call(
        self,
        name: str,
        arguments: dict[str, Any],
        result: dict[str, Any] | None = None,
        error: str | None = None,
    ) -> None:
        """Log a tool invocation."""
        tool_call = ToolCall(
            name=name,
            arguments=arguments,
            result=result,
            error=error,
        )
        self.trace.tool_calls.append(tool_call)
        status = "ERROR" if error else "OK"
        logger.info(f"[TOOL:{status}] {name}({json.dumps(arguments)[:100]}...)")

    def log_subagent_delegation(
        self,
        subagent_name: str,
        task_description: str,
        result: str | None = None,
    ) -> None:
        """Log a subagent task delegation."""
        delegation = SubagentDelegation(
            subagent_name=subagent_name,
            task_description=task_description,
            result=result,
        )
        self.trace.subagent_delegations.append(delegation)
        logger.info(f"[SUBAGENT] {subagent_name}: {task_description[:100]}...")

    def log_iteration(
        self,
        iteration: int,
        chain: list[str],
        framing: str,
        score: float,
        success: bool,
        failure_cause: str | None = None,
    ) -> None:
        """Log an attack iteration."""
        self._current_iteration = iteration
        iteration_data = {
            "iteration": iteration,
            "chain": chain,
            "framing": framing,
            "score": score,
            "success": success,
            "failure_cause": failure_cause,
            "timestamp": datetime.utcnow().isoformat(),
        }
        self.trace.iterations.append(iteration_data)
        status = "SUCCESS" if success else "FAILED"
        logger.info(
            f"[ITERATION {iteration}] {status} | "
            f"Score: {score:.2f} | Chain: {chain} | Framing: {framing}"
        )

    def log_final_result(self, result: dict[str, Any]) -> None:
        """Log the final execution result."""
        self.trace.final_result = result
        self.trace.end_time = datetime.utcnow().isoformat()
        logger.info(f"[FINAL] Success: {result.get('success')} | Score: {result.get('score', 0):.2f}")

    def save_trace(self) -> Path:
        """
        Save execution trace to JSON file.

        Returns:
            Path to saved trace file
        """
        timestamp = datetime.utcnow().strftime("%Y%m%d_%H%M%S")
        filename = f"trace_{self.trace.campaign_id}_{timestamp}.json"
        filepath = self.log_dir / filename

        # Convert dataclasses to dicts
        trace_dict = asdict(self.trace)

        with open(filepath, "w", encoding="utf-8") as f:
            json.dump(trace_dict, f, indent=2, default=str)

        logger.info(f"[TRACE] Saved to {filepath}")
        return filepath

    def get_summary(self) -> dict[str, Any]:
        """Get execution summary."""
        return {
            "campaign_id": self.trace.campaign_id,
            "target_url": self.trace.target_url,
            "total_iterations": len(self.trace.iterations),
            "total_decisions": len(self.trace.decisions),
            "total_tool_calls": len(self.trace.tool_calls),
            "total_subagent_delegations": len(self.trace.subagent_delegations),
            "final_success": self.trace.final_result.get("success") if self.trace.final_result else None,
            "final_score": self.trace.final_result.get("score") if self.trace.final_result else None,
        }


# Global logger instance for easy access
_current_logger: DecisionLogger | None = None


def get_decision_logger() -> DecisionLogger | None:
    """Get the current decision logger instance."""
    return _current_logger


def set_decision_logger(logger_instance: DecisionLogger) -> None:
    """Set the current decision logger instance."""
    global _current_logger
    _current_logger = logger_instance
