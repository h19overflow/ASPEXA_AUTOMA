"""
Success Evaluator Node.

Purpose: Evaluate attack success and determine routing
Role: Decision node - routes to continue, success, or exhausted
Dependencies: None (pure logic)

Routing Logic:
    - success: Attack succeeded, stop iteration
    - continue: Attack failed, more iterations available
    - exhausted: Max iterations reached without success
    - error: Unrecoverable error occurred
"""
import logging
from typing import Any, Literal

from services.snipers.deep_exploitation.state import DeepExploitationState

logger = logging.getLogger(__name__)


async def success_evaluator_node(
    state: DeepExploitationState,
) -> dict[str, Any]:
    """
    Evaluate attack success and prepare routing decision.

    This node checks success criteria and updates state for routing.

    Args:
        state: Current state with scores, iteration count, etc.

    Returns:
        State update with route, updated history, and tracking
    """
    iteration = state.get("iteration", 0)
    max_iterations = state.get("max_iterations", 5)
    success_threshold = state.get("success_threshold", 0.8)
    total_score = state.get("total_score", 0.0)
    is_successful = state.get("is_successful", False)
    selected_chain = state.get("selected_chain", [])
    error = state.get("error")
    best_score = state.get("best_score", 0.0)
    best_iteration = state.get("best_iteration", 0)
    iteration_history = list(state.get("iteration_history", []))
    tried_converters = list(state.get("tried_converters", []))
    tried_framings = list(state.get("tried_framings", []))
    preset_framing = state.get("preset_framing")
    custom_framing = state.get("custom_framing")

    logger.info(f"\n[SuccessEvaluator] Iteration {iteration}")
    logger.info(f"  Score: {total_score:.2f} (threshold: {success_threshold})")
    logger.info(f"  Is successful: {is_successful}")
    logger.info(f"  Best so far: {best_score:.2f} (iteration {best_iteration})")

    # Record iteration in history
    iteration_record = {
        "iteration": iteration,
        "score": total_score,
        "converters": selected_chain,
        "is_successful": is_successful,
        "framing": custom_framing.get("name") if custom_framing else preset_framing,
    }
    iteration_history.append(iteration_record)

    # Update tried lists
    if selected_chain and selected_chain not in tried_converters:
        tried_converters.append(selected_chain)

    framing_name = custom_framing.get("name") if custom_framing else preset_framing
    if framing_name and framing_name not in tried_framings:
        tried_framings.append(framing_name)

    # Update best score
    if total_score > best_score:
        best_score = total_score
        best_iteration = iteration

    # Determine route
    route: Literal["success", "continue", "exhausted", "error"]

    if error and "unrecoverable" in error.lower():
        route = "error"
        logger.info(f"  Route: ERROR - {error[:60]}")
    elif is_successful or total_score >= success_threshold:
        route = "success"
        logger.info(f"  Route: SUCCESS - Score {total_score:.2f} >= {success_threshold}")
    elif iteration >= max_iterations - 1:
        route = "exhausted"
        logger.info(f"  Route: EXHAUSTED - Reached max iterations ({max_iterations})")
    else:
        route = "continue"
        logger.info(f"  Route: CONTINUE - Iteration {iteration + 1}/{max_iterations}")

    return {
        "route": route,
        "iteration": iteration + 1 if route == "continue" else iteration,
        "iteration_history": iteration_history,
        "tried_converters": tried_converters,
        "tried_framings": tried_framings,
        "best_score": best_score,
        "best_iteration": best_iteration,
        "completed": route in ("success", "exhausted", "error"),
    }


def route_after_evaluation(state: DeepExploitationState) -> str:
    """
    Routing function for conditional edges.

    Returns the next node based on evaluation route.

    Args:
        state: Current state with route decision

    Returns:
        Node name: "analysis_start", "success_end", "exhausted_end", or "error_end"
    """
    route = state.get("route", "error")

    if route == "continue":
        return "analysis_start"
    elif route == "success":
        return "success_end"
    elif route == "exhausted":
        return "exhausted_end"
    else:
        return "error_end"
