"""
Chain Discovery Node.

Purpose: LLM-powered converter chain generation
Role: Generates optimal chain candidates based on failure analysis
Dependencies: ChainDiscoveryAgent component (LLM-powered)

Context Size: ~2KB input, ~1KB output
"""
import logging
from typing import Any

from libs.monitoring import CallbackHandler
from services.snipers.deep_exploitation.state import DeepExploitationState
from services.snipers.adaptive_attack.components.chain_discovery_agent import (
    ChainDiscoveryAgent,
)
from services.snipers.adaptive_attack.models.chain_discovery import (
    ChainDiscoveryContext,
    ChainDiscoveryDecision,
    ChainSelectionResult,
    ConverterChainCandidate,
)

logger = logging.getLogger(__name__)


async def chain_discovery_node(
    state: DeepExploitationState,
) -> dict[str, Any]:
    """
    Generate converter chain candidates via LLM.

    This node uses ChainDiscoveryAgent to produce structured
    chain candidates and selects the best one.

    Args:
        state: Current state with chain_discovery_context

    Returns:
        State update with chain_discovery_decision, chain_selection_result, selected_chain
    """
    iteration = state.get("iteration", 0)
    context = state.get("chain_discovery_context")
    tried_converters = state.get("tried_converters", [])
    phase1_result = state.get("phase1_result")

    # Extract objective from phase1 result
    objective = "test security boundaries"
    if phase1_result and hasattr(phase1_result, "garak_objective"):
        objective = phase1_result.garak_objective or objective

    logger.info(f"[ChainDiscovery] Iteration {iteration}: Generating chain candidates")

    # Handle missing context (fallback)
    if context is None:
        logger.warning("  No chain discovery context, using defaults")
        context = ChainDiscoveryContext()

    try:
        # Use existing ChainDiscoveryAgent
        agent = ChainDiscoveryAgent()
        handler = CallbackHandler()

        decision = await agent.generate(
            context=context,
            tried_converters=tried_converters,
            objective=objective,
            config={"callbacks": [handler], "run_name": "DeepChainDiscovery"},
        )

        logger.info(f"  Generated {len(decision.chains)} chain candidates")

        # Select best chain
        selection_result = agent.select_best_chain(decision, context)
        selected_chain = selection_result.selected_chain

        logger.info(f"  Selected chain: {selected_chain}")
        logger.info(f"  Selection method: {selection_result.selection_method}")

        return {
            "chain_discovery_decision": decision,
            "chain_selection_result": selection_result,
            "selected_chain": selected_chain,
        }

    except Exception as e:
        logger.error(f"  Chain discovery failed: {e}")
        # Fallback to default chain
        fallback_chain = ["homoglyph"]
        fallback_decision = ChainDiscoveryDecision(
            chains=[
                ConverterChainCandidate(
                    converters=fallback_chain,
                    expected_effectiveness=0.3,
                    defense_bypass_strategy="Fallback - LLM failed",
                    converter_interactions="N/A",
                )
            ],
            reasoning=f"Fallback due to error: {str(e)[:100]}",
            primary_defense_target="unknown",
            exploration_vs_exploitation="exploration",
            confidence=0.3,
        )
        fallback_selection = ChainSelectionResult(
            selected_chain=fallback_chain,
            selection_method="fallback",
            selection_reasoning=f"LLM error: {str(e)[:100]}",
            all_candidates=[],
            defense_match_details={},
            rejected_chains=[],
        )

        return {
            "chain_discovery_decision": fallback_decision,
            "chain_selection_result": fallback_selection,
            "selected_chain": fallback_chain,
            "error": f"Chain discovery error: {str(e)[:200]}",
        }
