"""
Failure Analyzer Node.

Purpose: Extract actionable intelligence from attack failures
Role: Second analysis node - produces ChainDiscoveryContext for chain discovery
Dependencies: FailureAnalyzer component (rule-based, no LLM)

Context Size: ~3KB input, ~2KB output
"""
import logging
from typing import Any

from services.snipers.deep_exploitation.state import DeepExploitationState
from services.snipers.adaptive_attack.components.failure_analyzer import (
    FailureAnalyzer,
)

logger = logging.getLogger(__name__)


async def failure_analyzer_node(
    state: DeepExploitationState,
) -> dict[str, Any]:
    """
    Analyze attack failure to extract chain discovery intelligence.

    This node is lightweight (no LLM) and produces structured
    context for the LLM-powered chain discovery node.

    Args:
        state: Current state with phase3_result, failure_cause, etc.

    Returns:
        State update with chain_discovery_context
    """
    iteration = state.get("iteration", 0)
    phase3_result = state.get("phase3_result")
    failure_cause = state.get("failure_cause")
    responses = state.get("target_responses", [])
    iteration_history = state.get("iteration_history", [])
    tried_converters = state.get("tried_converters", [])

    logger.info(f"[FailureAnalyzer] Iteration {iteration}: Analyzing failure")
    logger.info(f"  Failure cause: {failure_cause}")
    logger.info(f"  History length: {len(iteration_history)}")

    # Use existing FailureAnalyzer component
    analyzer = FailureAnalyzer()
    context = analyzer.analyze(
        phase3_result=phase3_result,
        failure_cause=failure_cause,
        target_responses=responses,
        iteration_history=iteration_history,
        tried_converters=tried_converters,
    )

    logger.info(f"  Defense signals: {context.defense_signals}")
    logger.info(f"  Root cause: {context.failure_root_cause[:60]}...")
    logger.info(f"  Unexplored: {context.unexplored_directions}")

    return {"chain_discovery_context": context}
