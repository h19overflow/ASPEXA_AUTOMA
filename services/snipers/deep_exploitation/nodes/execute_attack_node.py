"""
Execute Attack Node.

Purpose: Execute Phase 1-2-3 attack pipeline
Role: Core execution node - generates, converts, and executes payloads
Dependencies: PayloadArticulation, Conversion, AttackExecution

Context Size: Varies by payload count
"""
import logging
from typing import Any

from services.snipers.deep_exploitation.state import DeepExploitationState
from services.snipers.attack_phases import (
    PayloadArticulation,
    Conversion,
    AttackExecution,
)

logger = logging.getLogger(__name__)


async def execute_attack_node(
    state: DeepExploitationState,
) -> dict[str, Any]:
    """
    Execute the full attack pipeline (Phase 1-2-3).

    This node orchestrates payload generation, conversion,
    and attack execution with scoring.

    Args:
        state: Current state with campaign_id, target_url, selected_chain, etc.

    Returns:
        State update with phase results, target_responses, scores
    """
    iteration = state.get("iteration", 0)
    campaign_id = state.get("campaign_id", "")
    target_url = state.get("target_url", "")
    selected_chain = state.get("selected_chain", [])
    custom_framing = state.get("custom_framing")
    recon_custom_framing = state.get("recon_custom_framing")
    preset_framing = state.get("preset_framing")

    logger.info(f"\n[ExecuteAttack] Iteration {iteration}")
    logger.info(f"  Campaign: {campaign_id}")
    logger.info(f"  Target: {target_url}")
    logger.info(f"  Chain: {selected_chain}")
    logger.info(f"  Framing: {'custom' if custom_framing else preset_framing}")

    try:
        # === Phase 1: Payload Articulation ===
        logger.info("  Phase 1: Generating payloads...")
        phase1 = PayloadArticulation()

        # Determine framing type
        framing_types = [preset_framing] if preset_framing else None

        phase1_result = await phase1.execute(
            campaign_id=campaign_id,
            payload_count=3,
            framing_types=framing_types,
            custom_framing=custom_framing,
            recon_custom_framing=recon_custom_framing,
        )

        if not phase1_result or not phase1_result.articulated_payloads:
            return {
                "error": "Phase 1 failed: No payloads generated",
                "failure_cause": "error",
            }

        logger.info(f"    Generated {len(phase1_result.articulated_payloads)} payloads")

        # === Phase 2: Conversion ===
        logger.info(f"  Phase 2: Converting with {selected_chain}...")
        phase2 = Conversion()

        phase2_result = await phase2.execute(
            payloads=phase1_result.articulated_payloads,
            converter_names=selected_chain if selected_chain else None,
        )

        if not phase2_result or not phase2_result.payloads:
            return {
                "phase1_result": phase1_result,
                "error": "Phase 2 failed: No converted payloads",
                "failure_cause": "error",
            }

        logger.info(f"    Converted {len(phase2_result.payloads)} payloads")

        # === Phase 3: Attack Execution ===
        logger.info(f"  Phase 3: Executing attack against {target_url}...")
        phase3 = AttackExecution(target_url=target_url)

        phase3_result = await phase3.execute(
            campaign_id=campaign_id,
            payloads=phase2_result.payloads,
        )

        # Extract target responses for analysis
        target_responses = []
        if phase3_result and phase3_result.responses:
            for response in phase3_result.responses:
                if hasattr(response, "response_text"):
                    target_responses.append(response.response_text or "")
                elif isinstance(response, dict):
                    target_responses.append(response.get("response_text", ""))

        # Extract score
        total_score = 0.0
        is_successful = False
        if phase3_result:
            if hasattr(phase3_result, "overall_score"):
                total_score = phase3_result.overall_score or 0.0
            if hasattr(phase3_result, "is_successful"):
                is_successful = phase3_result.is_successful or False

        logger.info(f"    Responses: {len(target_responses)}")
        logger.info(f"    Score: {total_score:.2f}")
        logger.info(f"    Success: {is_successful}")

        # Determine failure cause
        failure_cause = None
        if not is_successful:
            if total_score > 0.3:
                failure_cause = "partial_success"
            elif total_score > 0:
                failure_cause = "no_impact"
            else:
                failure_cause = "blocked"

        return {
            "phase1_result": phase1_result,
            "phase2_result": phase2_result,
            "phase3_result": phase3_result,
            "target_responses": target_responses,
            "total_score": total_score,
            "is_successful": is_successful,
            "failure_cause": failure_cause,
        }

    except Exception as e:
        logger.error(f"  Attack execution failed: {e}")
        return {
            "error": f"Attack execution error: {str(e)[:200]}",
            "failure_cause": "error",
        }
